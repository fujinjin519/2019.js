<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>

        //    function fn(){
        //     //   3. console.log(a);// 形参加...a
        //     //   1. let b=[...arguments]
        //           //2.let b=Array.from(arguments)
        //            console.log(b);
        //    }
        //    fn(1,2,4)

        // var a=Array.of(1,2,3,4)
        // console.log(a);
        //    let fn=()=>{
        //        console.log(this);


        //    } 
        //    fn()
        // let obj={
        //     fn:()=>{
        //         console.log(this);


        //     }

        // }  
        // obj.fn()  // obj   window 找全局
        // fn()  //windown

        // let obj={
        //     fn:function(){
        //         return ()=>{
        //             console.log(this); //指向 obj,看它上一级作用域this是谁，上一级是obj,fn，this是obj,那它的this就是obj

        //         }

        //     }
        // }
        // var f=obj.fn()  

        // //  var ary=[1,2,3,41,1,2]
        //  let s=new Set()
        //  s.add(100) //向set数据结构中加值  。数据中不能有重复的值
        //  console.log(s); //  
        //  console.log(typeof s);  //找OBJ原型


        //  var ary=[1,2,3,41,1,2]   
        //  let s=new Set(ary)   //set传入的实参必须是    可遍历的结构：数组，类数组，对象
        //  console.log([...s]); //会实现数组去重

        // var a=1
        // var obj={a:a}    /{a}  名字一样可以省略
        // console.log(obj);

        // var a=1
        // var obj={
        //     a:1,
        //     fn:function fn(){
        //         console.log(100);
                

        //     }
        // }
        // obj.fn()

   
        // var a=1
        // var obj={
        //     a,
        //     fn(){
        //         console.log(100);
    //     }
        // }
        // obj.fn()
        // console.log(obj); //100
 
//    class min{}
        // class Bar {   //既不是函数的大括号也不是对象的大括号，只是一个独有的大括号
            
        //     constructor(x,y){ //在这里传参
        //         // this.x=x; //这个代码就是函数体中的代码  这里面也可以新增私有属性
        //         // this.y=y
        //         var a=1
        //     }
        //     //在原型上新增方法。因为它是函数类型的。不用写protype,直接新增了，
        //     //这不是箭头函数
        //     getx(){
        //         console.log(x);
                

        //     }
        //     gety(){
        //         console.log(y);
                
             
        //     }
        //            x=2 //这个相当于给实例增加私有属性。
        //     static x=1 //通过static ，可以给类新增私有属性 
        //                  // a不能用这个值，这个是自己的私有的。不是原型上的所以不能用
                   

        // }
        // console.log(typeof Bar); //函数类型 
        // // Bar.prototype.x=100  //给公有属性加，
        
        // let a = new Bar(1,2) //必须加new   传参数，在这里加
        // console.log(a.x);    // 2 


    //  class A{
    //      constructor(){
    //          this.x=1
    //      }
     
    //      getx=()=>{
    //          //实例私有的。等号就是私有的


    //      }
    //      get y(){
    //          //公有属性

    //      }

    //  }
    //  let a=new A
    //  //B的protyp中的--proto指向了A的原型
     
    //  class B extends A{
    //        constructor(){
    //            super() //写consturctor必须加super这个，不写这个报错，
    //            this.z=0
    //        }
    //      //B继承A
         


    //  }
    //  let b=new B
    //  console.log(a);
    //  console.log(b);  //继承私有和公有
     
     
//   var ary=[]
//   console.log(ary instanceof Array); // true
//   var obj={}
//   console.log(obj instanceof Array); // false
//   console.log(ary  instanceof Object ); //  true

  
//   function fn(){
       
//        console.log(arguments  instanceof  Array); //false    arguments指向object 
       

//   }
//   fn(1,23,4)

//   function fn(){
//       arguments.__proto__=Array.prototype
       
//        console.log(arguments  instanceof  Array); //true    改变它的指向就可以
       

//   }
//   fn(1,23,4)


//   var num=2
//   console.log(num  instanceof Number); //false   不能检测基本数据类型


//   var num= new Number(1)
//   console.log(num  instanceof Number) //true
  

// var ary=[]
// console.log(ary.constructor===Object ); //false 
// var obj={}

// var num=1
// console.log(num.constructor===Number); //true
// console.log(null.constructor===Number); //false


//   function A(){

//   }
//   A.prototype={}  //constructor丢失
//   var a=new A
//   a.constructor===A  //false。 找到object, 

    // var arr=[]
    // var obj={}
    // console.log(Object.prototype.toString.call(arr));  //[object Array]
    // console.log(toString.call(arr));////[object Array]
    
    // var num=1
    // console.log(Object.prototype.toString.call(num));//[object Number]
    // // console.log(toString.call(num));//[object Number]
    // var str="0101010"
    // var reg=/\d/
    // console.log(reg.test(str)); //true
    // console.log(reg);

    // var str="zhufeng12hh66"
    //     var reg=/\d+/g
    //  console.log(reg.exec(str)); //
    //  console.log(reg.exec(str)); //


//    var str="2019"
// //    var reg=/^\d+$/  //
//    var reg=/d/
//    console.log(reg.test(str));// true

    // var reg=/[xaf]/
    // reg.test('x')
    
    // console.log(   reg.test('x')); //true
    
//  var reg=/abc/
//  console.log(   reg.test('a')) //false
//  console.log(   reg.test('abshshshcb')) //false






   
     
    


    
  
  
  
    




    </script>
</body>

</html>