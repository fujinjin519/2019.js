<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <!--复习：
      免费课第一周：变量 数据类型  函数 选项卡
      变量  基本数据类型（栈内存提供代码运行环境）  引用数据类型（堆内存）
       number:数据类型
       数字：
       isnan :不是数字true  数字是false（把值先转数字）
       isnan(nan)//true
       parseFloat：识别小数点
       parseInt:不可识别小数点
       tofixed:保留小数点位数
       
       字符串：‘’ “”
       length 索引
       字符串方法：substr substring slice   
       
       boolean: true false  0 nan null undifined
       boolean("3px")// true
       boolean(obj.a) //false
      
       null : 获取不到元素就是null , 
       undifined: 几种情况

       引用数据类型：对象  函数
       
       对象：键值对 属性名:属性值    字段就是属性名
       增删改查 :对象中的属性名不能重复 
       对象没有索引 用 for  in循环

       数组：数组的方法 
        every:必须保证每一项都是true,都返回true,第一次是false,不输出
        some：找true,找到符合条件的那一项就不再循环   
        filter 
        find :找到符合条件的 没有就是undifined

      下午
      函数： 函数定义   函数执行  
       arguments实参集合
       return问题 
       匿名函数（没有名字） 自执行函数 
       箭头函数与普通函数的区别 ：没有this ,没有arguments采用剩余运算符, 不能被new,不能作为generator函数
       函数的三种角色:普通函数  构造函数类  普通对象
       数组去重的12中方法  
       https://blog.csdn.net/qq_29483485/article/details/83115224
       数组的十种经典算法 
       https://segmentfault.com/a/1190000020072884

       dom：
       获取元素
       节点类型：对象数据类型的
       
       元素节点   文本节点    注释节点    document
        1          3         8         9
                    #text   #coment    #document
       null         文本内容    注释内容      null

      动态操作节点：

       定时器 : 清定时器  
       异步：不会等
       setTimeout  setInterval
       
       正式课第一周：
       git  明白代码的解析过程 （堆栈内存，变量提升，作用域，函数执行的机制。this.面向对象
       浏览器形成堆栈内存，为代码执行提供必要的条件
       能用私有变量不用全局的变量
       栈内存销毁，堆内存也会随着销毁
       this:执行主体
       原型链：
       4种继承


：







      
 

         

       







 
      
      -->
  <script>
    // var fn=100
    // var obj={
    //   a:1,
    //   b:2
    // }
    // console.log(a);

    // var a = b = 100
    // var a
    // b = 100

    // b=200
    // var c=d={h:100}
    // d.h=300
    // var a = b = c = 12
    // console.log(a, b, c);
    // var a,b,c=12
    // console.log(a,b,c); //u u 12
    // var num=100.34

    // let a=document.getElementById("a")
    // console.log(a.previousElementSibling);

    //  $.ajax({
    //    url:"",
    //    data:{},//前端传递给后端的数据.这里面的简直对是根据接口文档里面出来的
    //    success:function(data){ //data:后端返回给前端的数据

    //    }

    //  })

    // var obj={}
    // var b="a"
    // obj.a=200
    // obj[b]=100
    // console.log(obj);//100

    //  var obj={a:1}
    //  obj.a=100

    //  var arr=[12,1,23,1]
    //  var obj={}
    //  for(let i=0;i<arr.length;i++){
    //    let  item=arr[i]
    //    if(obj[item]!=undefined){
    //      arr[i]=arr(arr.length-1)
    //      ary.length--
    //       i--
    //       continue

    //    }
    //    obj[item]=item

    //  }

    // let arr=[1,2,3,34,23]
    // let a=arr.map(function(a,b){
    //   return 100

    // })
    // console.log(a); //100 100 100 100 100
    // console.log(arr);

    // let a=arr.find(function(item,index){
    //   return item>300
    // }) 
    // console.log(a); //undifined

    //  let sum=arr.reduce(function(prev,next){
    //    return prev+next
    //  },0)
    //  console.log(sum); //求和

    //  function fn(){
    //    let a=100

    //  }
    //  fn()

    // function win(attr,val){
    //   if(typeof val==="undefined"){
    //     return document.documentElement[attr]
    //   }
    //   document.documentElement[attr]=val
    //   document.body[attr]=val
    // }
    // win("scrollTop")

    //  function f(num){
    //    if(num<0){
    //       return
    //    }
    //    f()
    //  }
    //  f(100);

    // (function () {

    // })() //自执行函数
    // var rr=function(){
    //   //把自己的空间地址给了rr.也属于匿名函数
    // }

    // let rr=(m,n)=>{return 100} 

    // rr()

    // let rr=m=> 100

    // rr()
    //  let obj={
    //    fn:function(){
    //      console.log(this);
    //     }
    //  }
    //  obj.fn()



    //  setInterval(function(){

    //  },1000)
    //  console.log();

  //   var a = 100
  //   function fn() {
  //     var a = 100
  //     return a
  //   }
  //  fn()

  //  function fn(){
  //    return function(){

  //    }
  //  }

  // function fn(){
  //   return function(){

  //   }
  // } 
  // let f=fn()  


//    let obj={
//      fn:(function(){


//      })()
//    }
// function fn(){
//   console.log();
// }
// fn.call(100);

// function Fn(){
//   //this:实例

// }
// Fn()
// var f=new Fn()

// new Fn()


// function A(){

// }
// function B(){
  
//    A.call(This)
//    arguments._proto_=Array.prototype;

// }
// A.prototype=new B
  let obj={};
  obj.call();
  fn.hasOwnProperty()
  console.log(obj.call);//undifined
  

  


  
  




















  </script>
</body>

</html>