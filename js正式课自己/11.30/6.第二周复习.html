<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 1.面向对象，大类小类， 
         2.构造函数，new可以构造函数的类和实例，类函数数据类型，实例对象数据类型，会默认return,return的值基本数据类型不受影响，引用数据类型受影响，函数在执行时跟普通函数执行唯一的区别就是，默认生成一个空对象，让函数里的this指向这个对象，默认把这个对象return出去，f就是fn的实例，this指向这个实例子
           this才跟当前实例有关系，其余的变量跟它，没关系
           new不管加不加括号就相当于执行了，

           newfn是函数数据类型的
           f是对象数据类型的
           

        3。自定义类：创建一个类，创建一个函数，执行的时候new执行（new出来的就是自定义类，自己创建的）
           内置类：（自带的比如Ary,Number都属于本来就带的）
        4.-instanceof：检测数据类型，检测实例是否属于某个类。tofix保留小数点后面两位。不能检测基本数据类型的值
        5.原型和原型链模式 （都画的是堆内存，有栈内存只是没画）。native code：内置字符串
         每一个类都是函数数据类型的，每一个-protype-也是一个对象，是对象就也有-pro-
         function是所有函数的基类
         object是所有对象的基类
         
         原型链查找：一级一级往上找，没有就是undifend(对象查找属性，通过--pro--)
         作用域链查找:要使用一个变量，看自己作用域有没有，上一级，找到全局，还没有就报错
        6.hasownpopt：检测后面的是不是前面的私有属性，是就是true,不是就是false
          in:检测属性是否属于某个对象是就是true反之
          instaceof:检测实例是否属于某个类
        7.原型链的this问题。
        8.原型重定向：类的原型被重新定向（指向新的内存地址）重构类的原型。重定向后的空间没有constrctor属性只有自己才有这个属性，内置类的原型不允许这么改
        9.四种继承：
        8.链式写法？
        call方法的应用
        ->
    <script>
    
    
    
    </script>
</body>
</html>