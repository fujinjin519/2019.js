<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
    //一，git  
         /* （1）工作区:（2）暂存区：（3）历史区：
         基本命令： 
            git config -l //查看全局配置信息
            git init //生成一个隐藏文件夹
            git add . //提交所有文件到暂存区
            git commit -m'描述信息'//提交到历史区
            git status //查看当前文件状态
            git log //查看历史版本信息
            git remote -v//查看本地仓库和哪些远程仓库保持连接
            git remote add origin [git仓库地址]//连接远程仓库
            git pull origin master//拉起远程仓库代码
            git push origin master//把本地代码传到远程
            git clone [远程仓库git地址]//克隆这个仓库 */


    //二 作用域：
         // (1)全局作用域 （scope）  私有作用域（为代码提供执行环境）
         //全局作用域 ： 当你打开一个页面，浏览器就会形成全局作用域为代码提供执行环境，在全局作用域下会生成一个全局的大对象叫window

         /* 全局作用域一般不销毁，直到页面关闭，作用域才会被销毁
            console.log(window)//显示全局作用域的所有名

            (1.1)全局变量：在全局作用下声明的变量就是全局变量 */
            /* 1.  用var和function声明的变量会在全局作用域下声明一个变量 ，而且也会给window增加属性，属性名是变量名，属性值是变量名存储的值（let const 不支持） */
            /*  2.var和function可以重复创建同一个变量名（let不可以） */
            /*   3.var和function有变量提升 */

        //(2)私有作用域：函数执行会形成一个私有的栈内存（私有作用域），全局作用域生成之后才会有私有作用域，私有作用域是属于全局作用域的

          //(2.1)私有变量
            //在私有作用域定义的变量就是私有变量（let,var,function,const）
            //形参也是私有变量
            //在私有作用域里使用一个变量，如果自己私有作用域有，就用自己的，没有使用上一级作用域的
             //函数外边不能拿到函数里边的变量

            //(2.2)变量提升：就是浏览器解析代码的一个过程
            //在当前作用域中，代码执行之前，浏览器会对当前作用域里带var和function进行提前声明和定义；
          /*   带var的会声明（创建变量）不定义，
            带function既声明（创建变量）又定义（进行赋值） */
    
        // SyntaxError(语法错误) 会使整个页面不运行 //引用错误ReferenceError 在当前代码之后的代码不运行
    
         // (2.3)●当浏览器开辟出供代码执行的栈内存之后，代码并没有自上而下立即执行，而是继续做了一些事情:把当前作用域中所有带var/function关键字的进行提前的声明和定义=>变量提升机制

         //(2.4)函数的作用域查找
        //函数的上一级作用域是谁，在函数定义时候已经确定了，函数在哪创建的，他的上一级作用域就是谁，跟在哪执行没有关系

        //(2.5)作用域链查找机制
        //在私有作用域中，函数执行，如果使用一个变量。自己作用要是有，就使用自己的，要是没有就向上一级作用域查找，上一级还没有，查到找到全局作用域，如果还没有就报错，  这种一级一级向上查找的机制就是【作用域链查找机制】

        //闭包：函数执行形成的私有作用域就是闭包，可以保护里边私有变量不受外界干扰；还可以保存变量

        //(3)四种特殊情况
        //1.变量提升发生在等号左边
         //2.不管if条件是否成立，都要进行变量提升  if条件里的function只声明不定义  
                 //在老版本浏览器里，if条件里的function既声明又定义
                    //在新版本浏览器里，if条件里的函数只声明不定义,为了兼容ES6严谨语法规范
                     //条件一旦成立，第一件事就是给函数名赋值
         //3.in 属性，检测一个对象当中有么有某个属性名，有就返回true，没有为false
         //4. 函数里虽然return下面的代码不执行，但要进行变量提升
         //5.匿名函数不进行变量提升(自执行函数)
            //(function(n){})(10);~function(n){}(10);-function(n){}(10);+function(n){}(10);!function(n){}(10);  //都是自执行函数


    //三 带var和不带var的区别 
        /*  1.全局作用域下 ： 不带var相当给全局对象window设置一个属性；带var声明一个变量，也相当于给window加了一个对应的属性（只有全局作用域具备这个特点） */


    //四  // let和var区别：
              //1.let和const不存在变量提升机制，var和function有变量提升
              /*   创建变量六种方式中：var和function有变量提升，而let,const,class,import不存在这个机制 */
              //2.var允许重复声明，而let不允许
               /*  在相同作用域中或执行上下文中，使用var和function声明变量并且重复声明，是不会有影响的（声明第一次后，在遇到就不再重复声明）
                但是let和const不行，浏览器会校验当前作用域中是否存在这个变量，已存在，则再次基于let等重新声明就会报错 */
             //3.let能解决typeof检测出现的暂时性死区问题(let比var更严谨)
                /*  console.log(a);//报错   a is not defined
                console.log(typeof a);//undefined  本该报错 ，bug浏览器死区
                解决方法;
                console.log(typeof a);
                let a; */
    
    //五  
        // 全局作用域（scope)
        // 全局执行上下文（context）
        // 全局栈内存（stack）
     /*    var a = 10,b = 20   ==   var a = 10; var b = 10
        var a = b = 10  ==  var a = 10; b = 10 (b不带var) */

    // 六
       /*  闭包作用域
        作用：1.保护 （私有变量和外界没有必然联系）
            2.保存 （形成不销毁的栈内存，里面的私有变量等信息保存下来了）
 */
             //函数定义：
         /*  1.首先开辟一个堆内存生成一个16进制的空间地址
          2.把函数体里的代码以字符串的格式存储进去
          3.把16进制的地址赋值给函数名 */
             //函数的上一级作用域是谁，在函数定义时候已经确定了，函数在哪创建的，他的上一级作用域就是谁，跟在哪执行没有关系
        //函数执行：
         /*    1.首先开辟一个私有作用域
            2.形参赋值
            3.变量提升
            4.代码从上往下执行
            /在私有作用域中，函数执行，如果使用一个变量。自己作用要是有，就使用自己的，要是没有就向上一级作用域查找，上一级还没有，查到找到全局作用域，如果还没有就报错，  这种一级一级向上查找的机制就是【作用域链查找机制】
            私有变量和外界的变量没有必然关系。理解为被私有栈内存保护了起来，这种机制就是闭包的保护机制
            5.作用域是否被销毁 */

    //七
      //     堆栈内存的销毁
            // 堆栈内存 复习
            //     打开一个页面，浏览器会形成两个虚拟的内存：堆内存、栈内存
            //     栈内存存储了啥：变量、基本数据类型值、地址
            //     堆内存存储了啥：存储了引用数据类型的值
            //     咱们的全局作用域、私有作用域都是栈内存，为代码执行提供必要的环境，理论上来说，存储
            //     的东西越少，运行的越快

            // 堆内存的销毁
            // 谷歌浏览器：谷歌浏览器每隔一段时间就会在当前作用域从头到尾检查一遍，看看有没有没有被占用的空间地址，如果有，就立即对其进行回收
            // IE和火狐：浏览器采用计数的规则，如果空间地址被占用一次，那这个空间地址就默认+1，每空闲一次，空间地址就默认-1，如果浏览器发现有为0的空间地址，就把其回收

             // 栈内存的销毁
        // 立即销毁
        // 不销毁    函数要return一个引用数据类型值
                    // return要被外界接收
                    // （1）函数要return一个引用数据类型值;（2）return的值要被外界接收
        // 不立即销毁
                    // 当外层大函数执行完成之后不能立即销毁，他要继续等待里面的小函数执行完成销毁之后，大函数在销毁
        /* 作用域就是栈内存：全局作用域、私有作用域
        1、全局作用域的销毁: 一般情况情况不销毁，除非把当前页面关闭，整个作用域就销毁了
        2、私有作用域的销毁：立即销毁、不销毁 、不立即销毁 */


// 七   选项卡的新办法

            //  //第四种方法
            //     //ES6中的let在for循环的大括号会形成块级作用域
            //     for(let i = 0; i<navList.length;i++){
            //         navList[i].onclick = function(){
            //             fn(i)
            //         }
            //     }


            //     //第三种方法：利用了闭包可以保存私有变量的特点，而且这个闭包是不销毁的变量
            //         /* for(var i = 0;i<navList.length;i++){
            //             navList[i].onclick =(function(index){
            //                 return function(){
            //                     fn(index)
            //                 }
            //             })(i)
            //         } */


//八  this
        
            /* this
            他是JS中的关键字，有特殊的意义
            他是函数的执行主体，谁执行函数，this就是谁
            在全局作用域下，this就是window
            在函数执行时，看执行函数前有没有“.”，如果有，点前面是谁，this就是谁；如果没有“.”，那this就是window
            自执行函数里的this是window
            给元素事件行为绑定方法，方法里的this指向被绑定的元素本身
            回调函数里的this一般指向window */
    </script>
</body>
</html>