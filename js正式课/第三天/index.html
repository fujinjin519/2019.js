<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        // console.log(a);//报错
        // console.log(typeof a)//'undefined'  
        
        console.log(typeof a)//a is no defined
        let a = 12;
        //ES6让js变得更加严谨

        //打开一个页面，浏览器会形成两个虚拟的内存：堆内存，栈内存

     /*    栈内存存储：  变量，基本数据类型值，地址
        堆内存：存储了引用数据类型的值

        全局作用域和私有作用域都是栈内存，为代码提供执行环境 
        理论上来说 存储的东西越少，运行越快 */


        // 堆栈内存销毁
        // 堆内存销毁  ：
        var obj = {};
        obj = null;
        //谷歌浏览器：每隔一段时间就会在当前作用域从头到尾检查一遍，看看有没有被占用的空间地址，如果有，就立即对其进行回收

        //IE和火狐：浏览器采用计数的规则，如果空间地址被占用一次，那这个空间地址就默认+1，每空闲一次，空间地址就默认-1，如果浏览器发现有为0的空间地址，就把其回收

       //闭包： 函数执行形成的私有作用域就是闭包，可以保护里边私有变量不受外界干扰；还可以保存变量




        //栈内存的销毁：
        // 立即销毁 不销毁 不立即销毁
        // 作用域就是栈内存：全局作用域 ，私有作用域
        // 1.全局作用域的销毁：一般情况下不销毁，除非把当前页面关闭，整个作用域就销毁了

        // 2.私有作用域的销毁：立即销毁，不销毁，不立即销毁
        //    1) 立即销毁   //基本数据类型 输出  接受后直接销毁

            function fn (){
                var name = 'jinyu',
                age = 18;
                return{
                    name:name,
                    age:age
                }
            }
            fn();//立即销毁 没人使用
            fn();//立即销毁 没人使用

            // 2) 不销毁：（1）函数要return一个引用数据类型值 (2)return的值要被外界接收
            function fn(){
                var name = 'jinyu',
                age = 18;
                return{
                    name:name,
                    age:age
                }
            }
            var res = fn()//不销毁 。值被接收


            function fn(){
                return function(){}
            }
            fn()()//不立即销毁
            //当外层大函数执行完成后不能立即销毁，他要等待里面的小函数执行完成之后销毁，大函数在销毁
    </script>
</body>
</html>