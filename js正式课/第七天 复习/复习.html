<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
   /*  一.全局作用域
        1.当你打开页面，浏览器就会形成全局作用域为代码提供执行环境，在全局作用域下会生成一个大的全局的大对象叫window
        全局作用域一般不销毁，直到页面关闭，才会销毁
        2.全局变量：
            在全局作用域下声明的变量就是全局变量
            用var和function声明的变量会在全局作用域下声明一个变量 ，而且也会给window增加属性，属性名是变量名，属性值是变量名所存储的值（let不支持）

    二.私有作用域
        1.全局作用域生成之后才会有私有作用域，私有作用域是属于全局作用域的
        函数执行会形成一个私有栈内存（为代码执行提供环境）
        2.私有变量：
            在私有作用域里边定义的变量就是私有变量（let var function const）
            形参也是私有变量
            在私有作用域里使用一个变量，如果自己私有作用域有，就是用自己的，如果没有，就使用上一级作用域的
            函数外边不能拿到函数里边的变量

    三.函数
        1.定义：
            首先开辟一个堆内存生成一个16进制的空间地址
            把函数体里的代码以字符串的格式存储进去
            把16进制地址赋值给函数名
        2.执行：
            首先开辟一个私有作用域，为代码执行提供环境
            形参赋值
            变量提升
            代码从上而下执行
            作用域是否被销毁
        
    四.变量提升
        1.含义：变量提升就是浏览器解析代码的一个过程
        2.使用：在当前作用域，代码执行之前，浏览器会对当前作用域里带var,function的进行提前声明和定义
          带var的会声明（创建变量）不定义，带function的既声明（创建变量）又定义（进行赋值）
        3.函数作用域查找：函数的上一级作用域是谁，在函数定义的时候已经确定了，函数在哪创建的，他的上一级作用域就是谁，跟在哪里执行没有关系
        4.作用域链查找机制：在私有作用域中，函数执行，如果要是用一个变量，自己作用域有，就用自己的，自己没有，就向上一级作用域查找，上一级还没有，就在向上一级查找，直到全局作用域，如果还没有就报错。这种一级一级向上查找的机制就是作用域链查找机制
        5.变量提升的特殊情况：
            （1）：变量提升发生在等号左边
            （2）：不管if条件是否成立，都要进行变量提升
            （3）：匿名函数不进行变量提升（自执行函数）
            （4）：函数里return下面的代码虽然不执行，但要进行变量提升
        6.●当浏览器开辟出供代码执行的栈内存之后，代码并没有自上而下立即执行，而是继续做了一些事情:把当前作用域中所有带var/function关键字的进行提前的声明和定义=>变量提升机制

    五.闭包
        1.含义：函数执行形成的私有作用域就是闭包，它可以保护里边的私有变量不受外界干扰，还可以保存变量
        2.in属性：他是检测一个对象有没有某个属性名，有返回true,没有为false
        3.instanceof:它是检测当前实例是否属于某个类，属于为true,不属于为false
                     写法：实例instanceof类 
                     局限性：instanceof不能检测基本数据类型，只能检测引用数据类型的值  检测基本数据类型检测不了只能为false
        4.hasOwnProperty:检测一个属性是否是自己的私有属性，是返回true,否为false
        5.typeof 特点：返回值是一个字符串，字符串里放着它的数据类型，
                缺点：检测普通对象，数组，null返回值都是object,所以typeof检测数据类型，无法将null.数组，普通对象细分4
        6.constructor:基于构造函数检测数据类型
        7.Object.prototype.toString.call()检测数据类型最好的方式 


    六.堆栈内存
        1.打开一个页面，浏览器就会形成2个虚拟的内存：堆内存，栈内存
            栈内存：存储了变量，基本数据类型的值，地址
            堆内存：存储了引用数据类型的值
            全局作用域，私有作用域都是栈内存，为代码执行提供必要的环境，理论来说，存储东西越少，运行越快
        2.堆内存的销毁：
            谷歌浏览器：每隔一段时间就会在当前作用域从头到尾检查一遍，看看有没有被占用的空间地址，如果有，就立即对其进行回收
            IE和火狐：浏览器采用计数的规则，如果空间地址被占用一次，那这个空间地址就默认+1，每空闲一次，空间地址默认-1，如果浏览器发现有为0的空间地址，就把其回收
        3.栈内存的销毁：
            （1）全局作用域的销毁：一般情况不销毁，除非把当前页面关闭，整个作用域就销毁了
            （2）私有作用域的销毁：
                    立即销毁
                    不销毁：（1）函数要return一个引用数据类型值（2）return要被外界接收
            （3）不立即销毁：当外层大函数执行完成后不能立即销毁，他要等待里面的小函数执行完成之后销毁，打函数在销毁

        七.this
            含义：它是js中的关键字，有特殊的特殊的意义
            this:它就是函数的执行主体，谁执行函数this就是谁
            this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的
            this的五种指向：
                在全局作用域下，this指向window
                自执行的函数的this是window
                回调函数的this一般指向window
                给元素事件行为绑定方法，方法里的this指向被绑定的元素本身
                函数执行时，看执行函数前有没有. ，如果有点，this就是谁，没有this为window
           
        八.面向对象
            1.单例模式：把描述同一个事物特征的信息进行分组归类，放到同一个命名空间下（减少全局变量的污染）
            2.高级单例模式：其实就是闭包
            3.工厂模式：批量生产，把实现相同功能的代码封装到函数里，以后想运行这个方法，就直接执行这个函数就好
                高内聚：提高代码的复用率
                低耦合：减少页面的重复代码
            4.标记语言：HTML/CSS   编程语言：JavaScript,PHP,C...   面向过程：C..  面向对象：JS,PHP
            5.研究实例：（1）研究实例的私有属性，（2）研究实例的公有属性，（3)一层一层找类的方法和属性

        九.构造函数
            1.构造自定义类 
            2.new  是js里的关键字   执行的时候：
                                        （1）：默认生成一个空对象
                                        （2）：让函数里的this指向这个对象
                                        （3）：代码执行
                                        （4）：默认return这个对象
             new函数执行叫做构造函数运行模式，此时的函数就是自定义类，函数执行之后返回结果就是一个对象，叫做实例对象（f就是这个函数的实例）
            3.类是函数数据类型的   实例是对象数据类型的    构造函数中的this指向当前实例

        十.构造函数和普通函数的区别：
            1.运行上的不同
                普通函数：形成私有作用域 -  形参赋值 - 变量提升 - 代码执行 - 作用域是否销毁
                构造函数：形成私有作用域 - 形参赋值 - 变量提升 - 默认生成一个对象 - 把this指向这个对象 - 代码执行  - 默认把这个对象return出去 - 作用域是否被销毁
            2.执行上的不同
                构造函数：如果不传是参，可以不加小括号   let a = new FN()这个可以去掉
            3.构造函数如果手动return一个基本数据类型值，不能改变其返回值，但手动return一个引用数据类型，可以改变构造函数的返回值，此时的return的东西已经不是当前类的实例了(所以不要轻易修改构造函数的返回值)

        十一.原型
            构造函数解决了实例的私有属性的问题，而原型模式解决了实例的公有属性问题
            1.每一个函数（普通函数，构造函数）都天生自带一个prototype属性，属性值是一个对象，它里面存储的是实例的公有属性（原型）
            2.每一个原型都天生自带consturctor属性,其属性指向当前类
            3.每一个对象都天生自带一个__proto__属性，其属性值指向当前所属类的原型

        十二.原型链的查找机制
            在对象里查找一个属性，先看自己私有的有没有，如果自己没有，就通过__proto__属性找到当前所属类的原型上，如果原型上有，就直接用，如果没有，通过原型的___proto__继续往Object类的原型上找，如果还没有，就是undefined,这种一级一级向上查找就会形成原型链

        十三.函数的三种角色
            1.普通函数
            2.构造函数
            3.普通对象
                所有函数都是function类的实例，那function也是函数，那他的__proto__指向的是自己的原型
                function是所有函数的基类
                object是所有对象的基类
                object的原型的__proto__指向自己，js认为指向自己没有意义，规定为null
                如果一个对象你不知道谁构出来的，那他的__proto__就指向object的原型（所有原型都指向object的原型）
            4.类的特点： 多态  封装   继承

        十四.var和let的区别
                 let和var区别：
                    1.let和const不存在变量提升机制，var和function有变量提升
                        创建变量六种方式中：var和function有变量提升，而let,const,class,import不存在这个机制
                    2.var允许重复声明，而let不允许
                        在相同作用域中或执行上下文中，使用var和function声明变量并且重复声明，是不会有影响的（声明第一次后，在遇到就不再重复声明）
                        但是let和const不行，浏览器会校验当前作用域中是否存在这个变量，已存在，则再次基于let等重新声明就会报错
                    3.let能解决typeof检测出现的暂时性死区问题(let比var更严谨)
                        console.log(a);报错   a is not defined
                        console.log(typeof a);undefined  本该报错 ，bug浏览器死区
                        解决方法;
                        console.log(typeof a);
                        let a;

        十五.其余
        SyntaxError(语法错误) 会使整个页面不运行     引用错误ReferenceError 在当前代码之后的代码不运行
            全局作用域（scope)
            全局执行上下文（context）
            全局栈内存（stack）
        let会形成块级作用域：
            let和{}结合就会形成块级作用域

        十六.选项卡的方法
        选项卡的新办法
            第四种方法
                //ES6中的let在for循环的大括号会形成块级作用域
                    for(let i = 0; i<navList.length;i++){
                        navList[i].onclick = function(){
                            fn(i)
                        }
                    }
 
             第三种方法：利用了闭包可以保存私有变量的特点，而且这个闭包是不销毁的变量
                    for(var i = 0;i<navList.length;i++){
                        navList[i].onclick =(function(index){
                            return function(){
                                fn(index)
                            }
                        })(i)
                    } 

                for(var i = 0;i<navList.length;i++){
            //第一种方法
                        navList[i].setAttribute('axe',i)
                        navList[i].onclick = function()
                {
                    fn(this.getAttribute('axe'))
                }  

            //第二种方法
                        navList[i].axe = i;
                        navList[i].onclick =function(){
                            fn(this.axe)
                        }
                }
                                    */
    </script>
</body>
</html>